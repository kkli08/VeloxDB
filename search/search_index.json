{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VeloxDB","text":"<p>VeloxDB is a persistent key-value store database library. It designed to store key-value pairs and allow efficient retrieval based on the key. This system is inspired by modern databases like LevelDB and RocksDB, and supports multiple data types using C++ Templates and Protocol Buffers.</p>"},{"location":"#supported-data-types","title":"Supported Data Types","text":"<p>2024-09-12 Restructure with <code>Protobuf</code> Using Protocol Buffer for data serialization</p> <pre><code>syntax = \"proto3\";\n\nmessage KeyValue {\n\n  oneof key {\n    int32 int_key = 1;\n    int64 long_key = 2;\n    double double_key = 3;\n    string string_key = 4;\n    string char_key = 5;\n  }\n\n  oneof value {\n    int32 int_value = 6;\n    int64 long_value = 7;\n    double double_value = 8;\n    string string_value = 9;\n    string char_value = 10;\n  }\n\n  enum KeyValueType {\n    INT = 0;\n    LONG = 1;\n    DOUBLE = 2;\n    CHAR = 3;\n    STRING = 4;\n\n  }\n\n  KeyValueType key_type = 11;\n  KeyValueType value_type = 12;\n}\n</code></pre> <p>2024-09-09 Support Template <pre><code>enum KeyValueType { INT, LONG, DOUBLE, CHAR, STRING };\n</code></pre> <p>2024-08-28 Support"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The KV-Store system has been tested across multiple platforms and compilers. Below is the current support status:</p> Platform Compiler Status MacOS ARM64 GCC \u2705 Ubuntu ARM64 GCC \u2705 Ubuntu ARM64 Clang \u2705 Windows x86 MSVC (cl) \u2705"},{"location":"#legacy-repo","title":"Legacy Repo","text":"<p>KvDB</p> <p>KV-Store</p>"},{"location":"api/","title":"Module","text":""},{"location":"api/#database-operations","title":"Database Operations","text":""},{"location":"api/#veloxdbopenstring-db_name","title":"VeloxDB::Open(string db_name)","text":"<p>Initializes the database system, setting up the necessary files and directories (including SSTs and related data). Can be initialized with a custom Memtable size or default size of <code>1e3</code>.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n/*\n *  Initialize with default value : \n *       Memtable::size == 1e3\n *       SsTFileManager::DiskBTree::Degree == 3\n */ \nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;();\nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;(int memtableSize, int BTreeDegree);\n\nMyDBDefault-&gt;Open(\"database_name\");\n</code></pre>"},{"location":"api/#veloxdbclose","title":"VeloxDB::Close()","text":"<p>Closes the database, flushing any data in memory (Memtable) to disk and storing it in SSTs.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Close the database and flush the Memtable to disk\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Close();\n</code></pre>"},{"location":"api/#data-operations","title":"Data Operations","text":""},{"location":"api/#template-veloxdbputk-key-v-value","title":"Template VeloxDB::Put(K key, V value) <p>Inserts a key-value pair into the database, where both the key and value can be of various types (int, double, string, etc.).</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Example of inserting different data types\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Put(1, 100);             // int -&gt; int\nMyDB-&gt;Put(1.5, 'A');           // double -&gt; char\nMyDB-&gt;Put(\"Hello\", 1e8LL);     // string -&gt; long long\n</code></pre>","text":""},{"location":"api/#veloxdbgetconst-keyvaluewrapper-key","title":"VeloxDB::Get(const KeyValueWrapper&amp; key) <p>Retrieves a value from the database based on the key. Supports multiple data types.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"kv/KeyValue.h\"\n// Example of retrieving values\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Put(1, 100);\nMyDB-&gt;Put(1.5, 'A');\nMyDB-&gt;Put(\"Hello\", 1e8LL);\n\n// Retrieve the value by key\nauto result1 = MyDB-&gt;Get(\"Hello\");\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// Retrieve the value by `KeyValueWrapper` instance\nauto result1 = MyDB-&gt;Get(KeyValueWrapper(\"Hello\", \"\")); \n// Expected result1: { key: \"Hello\", value: 1e8LL }\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// e.g.2\nauto result2 = MyDB-&gt;Get(1);\nint value2 = result2.kv.int_value();\nint key2 = results.kv.int_key();\n\n// check if not found using : bool KeyValueWrapper::isEmpty() const;\nif(result.isEmpty()){\n    // Key not found :-(\n} else {\n    // Found :-D\n}\n</code></pre>","text":""},{"location":"api/#veloxdbscankeyvaluewrapper-smallestkey-keyvaluewrapper-largestkey","title":"VeloxDB::Scan(KeyValueWrapper smallestKey, KeyValueWrapper largestKey) <p>Scans the database for key-value pairs within a specified key range. The results are returned in sorted key order.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Scan for key-value pairs within a range\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n// Scan by key\nstd::set&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(1, 10);\n// Scan by `KeyValueWrapper` instance\nstd::set&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(10, \"\"));\n</code></pre>","text":""},{"location":"api/#veloxdbupdatekeyvaluewrapper-keytoupdate","title":"VeloxDB::Update(KeyValueWrapper KeyToUpdate) <p>(TBA) This will allow the updating of key-value pairs within the database.</p>","text":""},{"location":"api/#veloxdbdeletekeyvaluewrapper-key","title":"VeloxDB::Delete(KeyValueWrapper Key) <p>(TBA) This will allow the deletion of key-value pairs from the database.</p>","text":""},{"location":"api/#buffer-pool-operation","title":"Buffer Pool Operation","text":""},{"location":"api/#setbufferpoolparameterssize_t-capacity-evictionpolicy-policy","title":"setBufferPoolParameters(size_t capacity, EvictionPolicy policy) <p>Set/reset buffer pool <code>size_t::</code> capacity and <code>EvictionPolicy::</code> policy (<code>LRU</code>, <code>CLOCK</code>, <code>RANDOM</code>)</p> <pre><code>EvictionPolicy newPolicy = EvictionPolicy::LRU;\nEvictionPolicy newPolicy = EvictionPolicy::CLOCK;\nEvictionPolicy newPolicy = EvictionPolicy::RANDOM;\n</code></pre>  <p>This method will clear all the previous cache in the buffer pool.</p>  <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"Memory/BufferPool/BufferPool.h\"\n// Open the database\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n\n// Set buffer pool parameters\nsize_t Capacity = 1e3;\nEvictionPolicy Policy = EvictionPolicy::CLOCK;\nMyDB-&gt;SetBufferPoolParameters(Capacity, Policy);\n\n// Reset \nsize_t newCapacity = 1e4;\nEvictionPolicy newPolicy = EvictionPolicy::LRU;\nMyDB-&gt;SetBufferPoolParameters(newCapacity, newPolicy);\n\n// Perform database operations\nMyDB-&gt;Put(1, \"value1\");\nKeyValueWrapper value = MyDB-&gt;Get(1);\n\n// Close the database\nMyDB-&gt;Close();\n</code></pre>","text":""},{"location":"api/#printcachehit","title":"printCacheHit() <p>print total number of cache hit in the buffer pool during the database operations.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n\nint memtableSize = 1e4; \nauto db = std::make_unique&lt;VeloxDB&gt;(memtableSize, 3);\ndb-&gt;Open(\"test_db\");\n\nconst int numEntries = 1e6;  // Insert 1e6 key-value pairs\n\n// Insert key-value pairs\nfor (int i = 0; i &lt; numEntries; ++i) {\n    db-&gt;Put(i, \"value_\" + std::to_string(i));\n}\n\nstd::set&lt;KeyValueWrapper&gt; resultSet = db-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(50000, \"\"));\n\ndb-&gt;printCacheHit(); // this will print the total number of cache hit in buffer pool\n\n// Clean up\ndb-&gt;Close();\n</code></pre>","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#benchmark","title":"Benchmark","text":""},{"location":"benchmark/#veloxdbput","title":"<code>VeloxDB::Put</code>","text":"<p><code>Put</code> throughput with different <code>Memtable</code> size</p> <pre><code>    B Tree Degree = 3\n    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbget","title":"<code>VeloxDB::Get</code>","text":"<p><code>Get</code> latency with different <code>Memtable</code> size</p> <pre><code>    B Tree Degree = 3\n    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbscan","title":"<code>VeloxDB::Scan</code>","text":"<p><code>Scan</code> throughput with different <code>Memtable</code> size</p> <pre><code>    B Tree Degree = 3\n    page size = 4 kb\n</code></pre> <p></p>"},{"location":"design/","title":"Database Design","text":""},{"location":"design/#tba","title":"TBA","text":""},{"location":"layout/","title":"Layout","text":""},{"location":"layout/#sst-files-layout","title":"SST Files Layout","text":"<pre><code>[Internal Node Page (Root)]\n[Internal Node Page 1]\n[Internal Node Page 2]\n...\n[Internal Node Page n]\n[Leaf Node Page 1]\n[Leaf Node Page 2]\n[Leaf Node Page 3]\n...\n[Leaf Node Page m]\n[* Clustered Index Page]\n[* Bloom Filter Page]\n[SST Metadata Page]\n</code></pre>"},{"location":"layout/#pagepagesize","title":"<code>Page::PageSize</code>","text":"<p>Page with <code>PageSize::</code> PageSize (<code>4KB</code>, <code>8KB</code>)</p>"},{"location":"layout/#pagesst_metadata","title":"<code>Page::SST_MetaData</code>","text":"<pre><code>LeafNode_Begin_Offset\nLeafNode_End_offset\nFileName\n</code></pre>"},{"location":"layout/#pageleafnodes","title":"<code>Page::LeafNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by key\n */\nserialized key-value pair 1 metadata (serialized by protobuf)\nserialized key-value pair 2 metadata (serialized by protobuf)\nserialized key-value pair 3 metadata (serialized by protobuf)\n...\n// with padding\n</code></pre>"},{"location":"layout/#pageinternalnodes","title":"<code>Page::InternalNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by level\n */\nlevel#0 key-value pair 0 metadata (serialized by protobuf), jump_offset_L1_K0, jump_offset_L1_K1\nlevel#1 key-value pair 1 metadata (serialized by protobuf), jump_offset_L2_K0, jump_offset_L2_K1\nlevel#1 key-value pair 2 metadata (serialized by protobuf), jump_offset_L2_K1, jump_offset_L2_K2\n...\n// with padding\n</code></pre>"},{"location":"layout/#pagebloomfilter","title":"<code>Page::BloomFilter</code>","text":"<p>TBD</p>"},{"location":"layout/#pageclusteredindex","title":"<code>Page::ClusteredIndex</code>","text":"<p>TBD</p>"}]}