{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VeloxDB","text":"<p>VeloxDB is a persistent key-value store database library. It designed to store key-value pairs and allow efficient retrieval based on the key. This system is inspired by modern databases like LevelDB and RocksDB, and supports multiple data types using C++ Templates and Protocol Buffers.</p> <p>2024-11-06 Restructure with LSM Tree;  </p>"},{"location":"#structure","title":"Structure","text":"Level Data Structure <code>Memory</code>, <code>L0</code> <code>Memtable</code> using <code>RB Tree</code> <code>Disk/SSD</code>, <code>L1+</code> <code>DiskBTree</code> using <code>Static B+ Tree</code>"},{"location":"#supported-data-types","title":"Supported Data Types","text":"<p>2024-09-12 Restructure with <code>Protobuf</code> Using Protocol Buffer for data serialization</p> <pre><code>syntax = \"proto3\";\n\nmessage KeyValue {\n\n  oneof key {\n    int32 int_key = 1;\n    int64 long_key = 2;\n    double double_key = 3;\n    string string_key = 4;\n    string char_key = 5;\n  }\n\n  oneof value {\n    int32 int_value = 6;\n    int64 long_value = 7;\n    double double_value = 8;\n    string string_value = 9;\n    string char_value = 10;\n  }\n\n  enum KeyValueType {\n    INT = 0;\n    LONG = 1;\n    DOUBLE = 2;\n    CHAR = 3;\n    STRING = 4;\n\n  }\n\n  KeyValueType key_type = 11;\n  KeyValueType value_type = 12;\n}\n</code></pre> <p>2024-09-09 Support Template <pre><code>enum KeyValueType { INT, LONG, DOUBLE, CHAR, STRING };\n</code></pre> <p>2024-08-28 Support"},{"location":"#supported-language","title":"Supported Language","text":"Language Status <code>C++</code> \u2705 <code>Rust</code> \u274e"},{"location":"#c-supported-platforms","title":"<code>C++</code> Supported Platforms","text":"<p>The KV-Store system has been tested across multiple platforms and compilers. Below is the current support status:</p> Platform Compiler Status MacOS ARM64 GCC \u2705 Ubuntu ARM64 GCC \u2705 Ubuntu ARM64 Clang \u2705 Windows x86 MSVC (cl) \u2705"},{"location":"#legacy-repo","title":"Legacy Repo","text":"<p>KvDB</p> <p>KV-Store</p>"},{"location":"api/","title":"Module","text":""},{"location":"api/#database-operations","title":"Database Operations","text":""},{"location":"api/#veloxdbopenstring-db_name","title":"VeloxDB::Open(string db_name)","text":"<p>Initializes and open the database system, setting up the necessary files and directories (including SSTs and related data). Can be initialized with a custom Memtable size or default size of <code>1e3</code>.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n/*\n *  Initialize with default value : \n *       Memtable::size == 1e3\n */ \nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;();\nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;(int memtableSize);\n\nMyDBDefault-&gt;Open(\"database_name\"); // open\n</code></pre>"},{"location":"api/#veloxdbclose","title":"VeloxDB::Close()","text":"<p>Close the database, flushing any data in memory (Memtable) to disk and storing it in SSTs.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Close the database and flush the Memtable to disk\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Close(); // close\n</code></pre>"},{"location":"api/#data-operations","title":"Data Operations","text":""},{"location":"api/#veloxdbgetconst-keyvaluewrapper-key","title":"VeloxDB::Get(const KeyValueWrapper&amp; key)","text":"<p>Retrieves a value from the database based on the key. Supports multiple data types.</p> <pre><code>template&lt;typename K, typename V&gt; \nvoid VeloxDB::Put(K key, V value)\n</code></pre> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"kv/KeyValue.h\"\n// Example of retrieving values\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Put(1, 100);\nMyDB-&gt;Put(1.5, 'A');\nMyDB-&gt;Put(\"Hello\", 1e8LL);\n\n// Retrieve the value by key\nauto result1 = MyDB-&gt;Get(\"Hello\");\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// Retrieve the value by `KeyValueWrapper` instance\nauto result1 = MyDB-&gt;Get(KeyValueWrapper(\"Hello\", \"\")); \n// Expected result1: { key: \"Hello\", value: 1e8LL }\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// e.g.2\nauto result2 = MyDB-&gt;Get(1);\nint value2 = result2.kv.int_value();\nint key2 = results.kv.int_key();\n\n// check if not found using : bool KeyValueWrapper::isEmpty() const;\nif(result.isEmpty()){\n    // Key not found :-(\n} else {\n    // Found :-D\n}\n</code></pre>"},{"location":"api/#veloxdbscankeyvaluewrapper-smallestkey-keyvaluewrapper-largestkey","title":"VeloxDB::Scan(KeyValueWrapper smallestKey, KeyValueWrapper largestKey)","text":"<p>Scans the database for key-value pairs within a specified key range. The results are returned in sorted key order.</p> <pre><code>template&lt;typename K1, typename K2&gt; \nstd::vector&lt;KeyValueWrapper&gt; VeloxDB::Scan(K1 small_key, K2 large_key)\n</code></pre> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Scan for key-value pairs within a range\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n// Scan by key\nstd::vector&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(1, 10);\n// Scan by `KeyValueWrapper` instance\nstd::vector&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(10, \"\"));\n</code></pre>"},{"location":"api/#template-veloxdbupdatek-key-v-value","title":"Template VeloxDB::Update(K Key, V Value) <p>This will allow the updating of key-value pairs within the database.</p> <p>(VeloxDB::Put actually would achieve the same result)</p> <pre><code>template&lt;typename K, typename V&gt;\nint VeloxDB::Update(K key, V value)\n</code></pre> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Example of inserting different data types\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nint Key = 1;\nMyDB-&gt;Put(Key, 100);                // int -&gt; int\n// update values with 'A'\nif(MyDB-&gt;Update(Key, 'A')){\n    // success update\n}else{\n    // No pair found by Key\n}             \n// update values with \"Hello World\"\nMyDB-&gt;Update(Key, \"Hello World\");   \n</code></pre>","text":""},{"location":"api/#template-veloxdbdeletek-key","title":"Template VeloxDB::Delete(K Key) <p>This will allow the deletion of key-value pair from the database. It will delete the kv pair by insert a new kv pair with the largest sequential number and set <code>Tombstone</code> to <code>true</code>. It will not been saved into SST file by the next <code>Merge</code> Operation inside LSM Tree structure.</p> <pre><code>template&lt;typename K&gt;\nvoid VeloxDB::Delete(K key)\n</code></pre> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Example of inserting different data types\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nint Key = 1;\nMyDB-&gt;Put(Key, 100);                // int -&gt; int\n// delete values with 'A'\nMyDB-&gt;Delete(Key);                  // equal to MyDB-&gt;Put(Key, 'A'); \n</code></pre>","text":""},{"location":"api/#buffer-pool-operation","title":"Buffer Pool Operation","text":""},{"location":"api/#setbufferpoolparameterssize_t-capacity-evictionpolicy-policy","title":"setBufferPoolParameters(size_t capacity, EvictionPolicy policy) <p>Set/reset buffer pool <code>size_t::</code> capacity and <code>EvictionPolicy::</code> policy (<code>LRU</code>, <code>CLOCK</code>, <code>RANDOM</code>)</p> <pre><code>EvictionPolicy newPolicy = EvictionPolicy::LRU;\nEvictionPolicy newPolicy = EvictionPolicy::CLOCK;\nEvictionPolicy newPolicy = EvictionPolicy::RANDOM;\n</code></pre>  <p>This method will clear all the previous cache in the buffer pool.</p>  <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"Memory/BufferPool/BufferPool.h\"\n// Open the database\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n\n// Set buffer pool parameters\nsize_t Capacity = 1e3;\nEvictionPolicy Policy = EvictionPolicy::CLOCK;\nMyDB-&gt;SetBufferPoolParameters(Capacity, Policy);\n\n// Reset \nsize_t newCapacity = 1e4;\nEvictionPolicy newPolicy = EvictionPolicy::LRU;\nMyDB-&gt;SetBufferPoolParameters(newCapacity, newPolicy);\n\n// Perform database operations\nMyDB-&gt;Put(1, \"value1\");\nKeyValueWrapper value = MyDB-&gt;Get(1);\n\n// Close the database\nMyDB-&gt;Close();\n</code></pre>","text":""},{"location":"api/#printcachehit","title":"printCacheHit() <p>print total number of cache hit in the buffer pool during the database operations.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n\nint memtableSize = 1e4; \nauto db = std::make_unique&lt;VeloxDB&gt;(memtableSize);\ndb-&gt;Open(\"test_db\");\n\nconst int numEntries = 1e6;  // Insert 1e6 key-value pairs\n\n// Insert key-value pairs\nfor (int i = 0; i &lt; numEntries; ++i) {\n    db-&gt;Put(i, \"value_\" + std::to_string(i));\n}\n\nstd::set&lt;KeyValueWrapper&gt; resultSet = db-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(50000, \"\"));\n\ndb-&gt;printCacheHit(); // this will print the total number of cache hit in buffer pool\n\n// Clean up\ndb-&gt;Close();\n</code></pre>","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#benchmark","title":"Benchmark","text":""},{"location":"benchmark/#veloxdbput","title":"<code>VeloxDB::Put</code>","text":"<p><code>Put</code> throughput with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbget","title":"<code>VeloxDB::Get</code>","text":"<p><code>Get</code> latency with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbscan","title":"<code>VeloxDB::Scan</code>","text":"<p><code>Scan</code> throughput with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"design/","title":"Database Design","text":""},{"location":"design/#lsm-tree","title":"LSM-Tree","text":"<pre><code>// LSMTree.h\nclass LSMTree {\npublic:\n    // Constructor with optional memtable size (default to 1000)\n    LSMTree(size_t memtableSize = 1000, const std::string&amp; dbPath = \"defaultDB\");\n\n    // Destructor\n    ~LSMTree();\n\n    // Save the state of the LSM tree to a .lsm file\n    void saveState();\n\n    // Load the state of the LSM tree from a .lsm file\n    void loadState();\n\n    // Insert a key-value pair into the LSM tree\n    void put(const KeyValueWrapper&amp; kv);\n\n    // Search for a key-value pair in the LSM tree\n    KeyValueWrapper get(const KeyValueWrapper&amp; kv);\n\n    // Scan method\n    void scan(const KeyValueWrapper&amp; startKey, const KeyValueWrapper&amp; endKey, std::vector&lt;KeyValueWrapper&gt;&amp; result);\n\n    // ...\n\nprivate:\n    // Level 0 is always the in-memory memtable\n    std::unique_ptr&lt;Memtable&gt; memtable; // Level 0\n\n    // Levels 1 and above consist of DiskBTrees (SSTables)\n    // Each level holds at most one SSTable\n    std::vector&lt;std::shared_ptr&lt;DiskBTree&gt;&gt; levels; // Levels 1+\n\n    // Size Ratio of the LSM-Tree between levels\n    size_t fixedSizeRatio = 2;\n\n    // Level capacities (maximum number of key-value pairs per level)\n    std::vector&lt;size_t&gt; levelMaxSizes;\n\n    // Path to the .lsm file and database directory\n    fs::path dbPath;\n    fs::path lsmFilePath;\n\n    // Helper methods\n    void initializeLSM();\n\n    // Handle flushing memtable to Level 1\n    void flushMemtableToLevel1();\n\n    // Merge SSTables when a level exceeds its capacity\n    void mergeLevels(int level, const std::shared_ptr&lt;DiskBTree&gt;&amp; sstToMerge);\n\n    // Merge two SSTables into a new SSTable\n    void mergeSSTables(const std::shared_ptr&lt;DiskBTree&gt;&amp; sst1,\n                       const std::shared_ptr&lt;DiskBTree&gt;&amp; sst2,\n                       const std::string&amp; outputSSTableFileName,\n                       std::vector&lt;KeyValueWrapper&gt;&amp; leafPageSmallestKeys,\n                       int&amp; numberOfPages,\n                       int&amp; totalKvs);\n\n    // ...\n};\n</code></pre>"},{"location":"design/#buffer-pool","title":"Buffer Pool","text":"<pre><code>// PageManager.h\nclass PageManager {\npublic:\n    // ...\n\n    // BufferPool configuration\n    void setBufferPoolParameters(size_t capacity, EvictionPolicy policy);\n    long long getCacheHit() const {return bufferPool-&gt;getCacheHit();};\n\n    // ...\n\nprivate:\n    // ...\n\n    // shared buffer pool among all the pageManager\n    std::shared_ptr&lt;BufferPool&gt; bufferPool;\n\n    // ...\n};\n</code></pre>"},{"location":"design/#bloom-filter","title":"Bloom Filter","text":"<pre><code>// VeloxDB.h\n\n// Set buffer pool parameters\nvoid setBufferPoolParameters(size_t capacity, EvictionPolicy policy);\n\n// Print total CacheHit in the buffer pool\nvoid printCacheHit() const;\n</code></pre>"},{"location":"design/#static-b-tree-as-sst-file","title":"Static B+ Tree as SST file","text":""},{"location":"design/#writing-into-sst-file","title":"Writing into sst file","text":"<pre><code>DiskBTree::DiskBTree(const std::string&amp; sstFileName, const std::vector&lt;KeyValueWrapper&gt;&amp; keyValues, size_t pageSize)\n    : sstFileName(sstFileName), pageManager(sstFileName, pageSize), pageSize(pageSize), root(nullptr)\n{\n    // Constructor for creating a new SST file\n\n    // Step 1: Write placeholder metadata to offset 0\n    Page metadataPage(Page::PageType::SST_METADATA);\n    pageManager.writePage(0, metadataPage); // Reserve offset 0\n\n    // Step 2: Split keyValues into leaf pages\n    splitInputPairs(keyValues);\n\n    // Step 3: Compute degree and height\n    computeDegreeAndHeight();\n\n    // Step 4: Build the tree\n    buildTree();\n\n    // Step 5: Write the tree into the SST file\n    writeTreeToSST();\n\n    // Step 6: Set the root offset\n    rootOffset = root-&gt;offset;\n\n    // Step 7: Update and write the metadata page with the actual root offset\n    metadataPage.setMetadata(rootOffset, leafBeginOffset, leafEndOffset, sstFileName);\n    pageManager.writePage(0, metadataPage);\n\n    // After writing, clear the in-memory structures to free memory\n    // ...\n}\n</code></pre>"},{"location":"design/#reading-sst-file","title":"Reading sst file","text":"<pre><code>DiskBTree::DiskBTree(const std::string&amp; sstFileName)\n    : sstFileName(sstFileName), pageManager(sstFileName), root(nullptr)\n{\n    // Constructor for reading an existing SST file\n\n    // Read the metadata page from offset 0\n    Page metadataPage = pageManager.readPage(0);\n\n    // Extract metadata\n    std::string fileName;\n    metadataPage.getMetadata(rootOffset, leafBeginOffset, leafEndOffset, fileName);\n\n    // sstFileName is already set; ensure it matches the metadata (optional)\n    if (sstFileName != fileName) {\n        std::cerr &lt;&lt; \"Warning: SST file name does not match metadata file name.\" &lt;&lt; std::endl;\n    }\n\n    // Since the tree is static, we don't load any nodes into memory\n    // We rely on reading pages from disk during search and scan operations\n}\n</code></pre>"},{"location":"layout/","title":"Layout","text":""},{"location":"layout/#sst-files-layout","title":"SST Files Layout","text":"<pre><code>[SST Metadata Page]\n[Leaf Node Page 1]\n[Leaf Node Page 2]\n[Leaf Node Page 3]\n...\n[Leaf Node Page m]\n[Internal Node Page (Root)]\n[Internal Node Page 1]\n[Internal Node Page 2]\n...\n[Internal Node Page n]\n[* Clustered Index Page]\n[* Bloom Filter Page]\n</code></pre>"},{"location":"layout/#pagepagesize","title":"<code>Page::PageSize</code>","text":"<p>Page with <code>PageSize::</code> PageSize (<code>4KB</code>, <code>8KB</code>)</p>"},{"location":"layout/#pagesst_metadata","title":"<code>Page::SST_MetaData</code>","text":"<pre><code>struct SSTMetadata {\n        uint64_t rootPageOffset;\n        uint64_t leafNodeBeginOffset;\n        uint64_t leafNodeEndOffset;\n        std::string fileName;\n\n        // SST Bloom filter\n        BloomFilter bloomFilter;\n        bool hasBloomFilter = false;\n    }\n</code></pre>"},{"location":"layout/#pageleafnodes","title":"<code>Page::LeafNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by key\n */\nserialized key-value pair 1 metadata (serialized by protobuf)\nserialized key-value pair 2 metadata (serialized by protobuf)\nserialized key-value pair 3 metadata (serialized by protobuf)\n...\nBloom Filter for each Leaf Page\n// with padding\n</code></pre> <pre><code>struct LeafNodeData {\n        std::vector&lt;KeyValueWrapper&gt; keyValues;\n        uint64_t nextLeafOffset; // Offset to next leaf node\n\n        // Bloom filter for the leaf node\n        BloomFilter bloomFilter;\n        bool hasBloomFilter = false;\n    }\n</code></pre>"},{"location":"layout/#pageinternalnodes","title":"<code>Page::InternalNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by level\n */\nlevel#0 key-value pair 0 metadata (serialized by protobuf), jump_offset_L1_K0, jump_offset_L1_K1\nlevel#1 key-value pair 1 metadata (serialized by protobuf), jump_offset_L2_K0, jump_offset_L2_K1\nlevel#1 key-value pair 2 metadata (serialized by protobuf), jump_offset_L2_K1, jump_offset_L2_K2\n...\n// with padding\n</code></pre> <pre><code>struct InternalNodeData {\n        std::vector&lt;KeyValueWrapper&gt; keys;\n        std::vector&lt;uint64_t&gt; childOffsets; // Offsets to child pages, size = keys.size() + 1\n    }\n</code></pre>"},{"location":"layout/#pagebloomfilter","title":"<code>Page::BloomFilter</code>","text":"<p>TBD</p>"},{"location":"layout/#pageclusteredindex","title":"<code>Page::ClusteredIndex</code>","text":"<p>TBD</p>"}]}