{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VeloxDB","text":"<p>VeloxDB is a persistent key-value store database library. It designed to store key-value pairs and allow efficient retrieval based on the key. This system is inspired by modern databases like LevelDB and RocksDB, and supports multiple data types using C++ Templates and Protocol Buffers.</p>"},{"location":"#supported-data-types","title":"Supported Data Types","text":"<p>2024-09-12 Restructure with <code>Protobuf</code> Using Protocol Buffer for data serialization</p> <pre><code>syntax = \"proto3\";\n\nmessage KeyValue {\n\n  oneof key {\n    int32 int_key = 1;\n    int64 long_key = 2;\n    double double_key = 3;\n    string string_key = 4;\n    string char_key = 5;\n  }\n\n  oneof value {\n    int32 int_value = 6;\n    int64 long_value = 7;\n    double double_value = 8;\n    string string_value = 9;\n    string char_value = 10;\n  }\n\n  enum KeyValueType {\n    INT = 0;\n    LONG = 1;\n    DOUBLE = 2;\n    CHAR = 3;\n    STRING = 4;\n\n  }\n\n  KeyValueType key_type = 11;\n  KeyValueType value_type = 12;\n}\n</code></pre> <p>2024-09-09 Support Template <pre><code>enum KeyValueType { INT, LONG, DOUBLE, CHAR, STRING };\n</code></pre> <p>2024-08-28 Support"},{"location":"#supported-language","title":"Supported Language","text":"Language Status <code>C++</code> \u2705 <code>Rust</code> \u274e"},{"location":"#c-supported-platforms","title":"<code>C++</code> Supported Platforms","text":"<p>The KV-Store system has been tested across multiple platforms and compilers. Below is the current support status:</p> Platform Compiler Status MacOS ARM64 GCC \u2705 Ubuntu ARM64 GCC \u2705 Ubuntu ARM64 Clang \u2705 Windows x86 MSVC (cl) \u2705"},{"location":"#legacy-repo","title":"Legacy Repo","text":"<p>KvDB</p> <p>KV-Store</p>"},{"location":"api/","title":"Module","text":""},{"location":"api/#database-operations","title":"Database Operations","text":""},{"location":"api/#veloxdbopenstring-db_name","title":"VeloxDB::Open(string db_name)","text":"<p>Initializes and open the database system, setting up the necessary files and directories (including SSTs and related data). Can be initialized with a custom Memtable size or default size of <code>1e3</code>.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n/*\n *  Initialize with default value : \n *       Memtable::size == 1e3\n */ \nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;();\nauto MyDBDefault = std::make_unique&lt;VeloxDB&gt;(int memtableSize);\n\nMyDBDefault-&gt;Open(\"database_name\"); // open\n</code></pre>"},{"location":"api/#veloxdbclose","title":"VeloxDB::Close()","text":"<p>Close the database, flushing any data in memory (Memtable) to disk and storing it in SSTs.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Close the database and flush the Memtable to disk\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Close(); // close\n</code></pre>"},{"location":"api/#data-operations","title":"Data Operations","text":""},{"location":"api/#template-veloxdbputk-key-v-value","title":"Template VeloxDB::Put(K key, V value) <p>Inserts a key-value pair into the database, where both the key and value can be of various types (int, double, string, etc.).</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Example of inserting different data types\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n// put\nMyDB-&gt;Put(1, 100);             // int -&gt; int\nMyDB-&gt;Put(1.5, 'A');           // double -&gt; char\nMyDB-&gt;Put(\"Hello\", 1e8LL);     // string -&gt; long long\n</code></pre>","text":""},{"location":"api/#veloxdbgetconst-keyvaluewrapper-key","title":"VeloxDB::Get(const KeyValueWrapper&amp; key) <p>Retrieves a value from the database based on the key. Supports multiple data types.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"kv/KeyValue.h\"\n// Example of retrieving values\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\nMyDB-&gt;Put(1, 100);\nMyDB-&gt;Put(1.5, 'A');\nMyDB-&gt;Put(\"Hello\", 1e8LL);\n\n// Retrieve the value by key\nauto result1 = MyDB-&gt;Get(\"Hello\"); // get\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// Retrieve the value by `KeyValueWrapper` instance\nauto result1 = MyDB-&gt;Get(KeyValueWrapper(\"Hello\", \"\")); \n// Expected result1: { key: \"Hello\", value: 1e8LL }\nlong long value1 = result1.kv.long_value(); // 1e8\nstring key1 = result1.kv.string_key(); // \"Hello\"\n\n// e.g.2\nauto result2 = MyDB-&gt;Get(1);\nint value2 = result2.kv.int_value();\nint key2 = results.kv.int_key();\n\n// check if not found using : bool KeyValueWrapper::isEmpty() const;\nif(result.isEmpty()){\n    // Key not found :-(\n} else {\n    // Found :-D\n}\n</code></pre>","text":""},{"location":"api/#veloxdbscankeyvaluewrapper-smallestkey-keyvaluewrapper-largestkey","title":"VeloxDB::Scan(KeyValueWrapper smallestKey, KeyValueWrapper largestKey) <p>Scans the database for key-value pairs within a specified key range. The results are returned in sorted key order.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n// Scan for key-value pairs within a range\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n// Scan by key\nstd::set&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(1, 10); // scan\n// Scan by `KeyValueWrapper` instance\nstd::set&lt;KeyValueWrapper&gt; results = MyDB-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(10, \"\"));\n</code></pre>","text":""},{"location":"api/#veloxdbupdatekeyvaluewrapper-keytoupdate","title":"VeloxDB::Update(KeyValueWrapper KeyToUpdate) <p>(TBA) This will allow the updating of key-value pairs within the database.</p>","text":""},{"location":"api/#veloxdbdeletekeyvaluewrapper-key","title":"VeloxDB::Delete(KeyValueWrapper Key) <p>(TBA) This will allow the deletion of key-value pairs from the database.</p>","text":""},{"location":"api/#buffer-pool-operation","title":"Buffer Pool Operation","text":""},{"location":"api/#setbufferpoolparameterssize_t-capacity-evictionpolicy-policy","title":"setBufferPoolParameters(size_t capacity, EvictionPolicy policy) <p>Set/reset buffer pool <code>size_t::</code> capacity and <code>EvictionPolicy::</code> policy (<code>LRU</code>, <code>CLOCK</code>, <code>RANDOM</code>)</p> <pre><code>EvictionPolicy newPolicy = EvictionPolicy::LRU;\nEvictionPolicy newPolicy = EvictionPolicy::CLOCK;\nEvictionPolicy newPolicy = EvictionPolicy::RANDOM;\n</code></pre>  <p>This method will clear all the previous cache in the buffer pool.</p>  <pre><code>#include \"VeloxDB/VeloxDB.h\"\n#include \"Memory/BufferPool/BufferPool.h\"\n// Open the database\nauto MyDB = std::make_unique&lt;VeloxDB&gt;();\nMyDB-&gt;Open(\"database_name\");\n\n// Set buffer pool parameters\nsize_t Capacity = 1e3;\nEvictionPolicy Policy = EvictionPolicy::CLOCK;\nMyDB-&gt;SetBufferPoolParameters(Capacity, Policy);\n\n// Reset \nsize_t newCapacity = 1e4;\nEvictionPolicy newPolicy = EvictionPolicy::LRU;\nMyDB-&gt;SetBufferPoolParameters(newCapacity, newPolicy);\n\n// Perform database operations\nMyDB-&gt;Put(1, \"value1\");\nKeyValueWrapper value = MyDB-&gt;Get(1);\n\n// Close the database\nMyDB-&gt;Close();\n</code></pre>","text":""},{"location":"api/#printcachehit","title":"printCacheHit() <p>print total number of cache hit in the buffer pool during the database operations.</p> <pre><code>#include \"VeloxDB/VeloxDB.h\"\n\nint memtableSize = 1e4; \nauto db = std::make_unique&lt;VeloxDB&gt;(memtableSize);\ndb-&gt;Open(\"test_db\");\n\nconst int numEntries = 1e6;  // Insert 1e6 key-value pairs\n\n// Insert key-value pairs\nfor (int i = 0; i &lt; numEntries; ++i) {\n    db-&gt;Put(i, \"value_\" + std::to_string(i));\n}\n\nstd::set&lt;KeyValueWrapper&gt; resultSet = db-&gt;Scan(KeyValueWrapper(1, \"\"), KeyValueWrapper(50000, \"\"));\n\ndb-&gt;printCacheHit(); // this will print the total number of cache hit in buffer pool\n\n// Clean up\ndb-&gt;Close();\n</code></pre>","text":""},{"location":"benchmark/","title":"Benchmark","text":""},{"location":"benchmark/#benchmark","title":"Benchmark","text":""},{"location":"benchmark/#veloxdbput","title":"<code>VeloxDB::Put</code>","text":"<p><code>Put</code> throughput with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbget","title":"<code>VeloxDB::Get</code>","text":"<p><code>Get</code> latency with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"benchmark/#veloxdbscan","title":"<code>VeloxDB::Scan</code>","text":"<p><code>Scan</code> throughput with different <code>Memtable</code> size</p> <pre><code>    page size = 4 kb\n</code></pre> <p></p>"},{"location":"design/","title":"Database Design","text":""},{"location":"design/#buffer-pool","title":"Buffer Pool","text":"<pre><code>// PageManager.h\nclass PageManager {\npublic:\n    // ...\n\n    // BufferPool configuration\n    void setBufferPoolParameters(size_t capacity, EvictionPolicy policy);\n    long long getCacheHit() const {return bufferPool-&gt;getCacheHit();};\n\n    // ...\n\nprivate:\n    // ...\n\n    // shared buffer pool among all the pageManager\n    std::shared_ptr&lt;BufferPool&gt; bufferPool;\n\n    // ...\n};\n</code></pre>"},{"location":"design/#bloom-filter","title":"Bloom Filter","text":"<p>TBD</p>"},{"location":"design/#static-b-tree-as-sst-file","title":"Static B+ Tree as SST file","text":""},{"location":"design/#writing-into-sst-file","title":"Writing into sst file","text":"<pre><code>DiskBTree::DiskBTree(const std::string&amp; sstFileName, const std::vector&lt;KeyValueWrapper&gt;&amp; keyValues, size_t pageSize)\n    : sstFileName(sstFileName), pageManager(sstFileName, pageSize), pageSize(pageSize), root(nullptr)\n{\n    // Constructor for creating a new SST file\n\n    // Step 1: Write placeholder metadata to offset 0\n    Page metadataPage(Page::PageType::SST_METADATA);\n    pageManager.writePage(0, metadataPage); // Reserve offset 0\n\n    // Step 2: Split keyValues into leaf pages\n    splitInputPairs(keyValues);\n\n    // Step 3: Compute degree and height\n    computeDegreeAndHeight();\n\n    // Step 4: Build the tree\n    buildTree();\n\n    // Step 5: Write the tree into the SST file\n    writeTreeToSST();\n\n    // Step 6: Set the root offset\n    rootOffset = root-&gt;offset;\n\n    // Step 7: Update and write the metadata page with the actual root offset\n    metadataPage.setMetadata(rootOffset, leafBeginOffset, leafEndOffset, sstFileName);\n    pageManager.writePage(0, metadataPage);\n\n    // After writing, clear the in-memory structures to free memory\n    // ...\n}\n</code></pre>"},{"location":"design/#reading-sst-file","title":"Reading sst file","text":"<pre><code>DiskBTree::DiskBTree(const std::string&amp; sstFileName)\n    : sstFileName(sstFileName), pageManager(sstFileName), root(nullptr)\n{\n    // Constructor for reading an existing SST file\n\n    // Read the metadata page from offset 0\n    Page metadataPage = pageManager.readPage(0);\n\n    // Extract metadata\n    std::string fileName;\n    metadataPage.getMetadata(rootOffset, leafBeginOffset, leafEndOffset, fileName);\n\n    // sstFileName is already set; ensure it matches the metadata (optional)\n    if (sstFileName != fileName) {\n        std::cerr &lt;&lt; \"Warning: SST file name does not match metadata file name.\" &lt;&lt; std::endl;\n    }\n\n    // Since the tree is static, we don't load any nodes into memory\n    // We rely on reading pages from disk during search and scan operations\n}\n</code></pre>"},{"location":"design/#lsm-tree","title":"LSM-Tree","text":"<p>TBD</p>"},{"location":"layout/","title":"Layout","text":""},{"location":"layout/#sst-files-layout","title":"SST Files Layout","text":"<pre><code>[SST Metadata Page]\n[Leaf Node Page 1]\n[Leaf Node Page 2]\n[Leaf Node Page 3]\n...\n[Leaf Node Page m]\n[Internal Node Page (Root)]\n[Internal Node Page 1]\n[Internal Node Page 2]\n...\n[Internal Node Page n]\n[* Clustered Index Page]\n[* Bloom Filter Page]\n</code></pre>"},{"location":"layout/#pagepagesize","title":"<code>Page::PageSize</code>","text":"<p>Page with <code>PageSize::</code> PageSize (<code>4KB</code>, <code>8KB</code>)</p>"},{"location":"layout/#pagesst_metadata","title":"<code>Page::SST_MetaData</code>","text":"<pre><code>struct SSTMetadata {\n        uint64_t rootPageOffset;\n        uint64_t leafNodeBeginOffset;\n        uint64_t leafNodeEndOffset;\n        std::string fileName;\n\n        // SST Bloom filter\n        BloomFilter bloomFilter;\n        bool hasBloomFilter = false;\n    }\n</code></pre>"},{"location":"layout/#pageleafnodes","title":"<code>Page::LeafNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by key\n */\nserialized key-value pair 1 metadata (serialized by protobuf)\nserialized key-value pair 2 metadata (serialized by protobuf)\nserialized key-value pair 3 metadata (serialized by protobuf)\n...\nBloom Filter for each Leaf Page\n// with padding\n</code></pre> <pre><code>struct LeafNodeData {\n        std::vector&lt;KeyValueWrapper&gt; keyValues;\n        uint64_t nextLeafOffset; // Offset to next leaf node\n\n        // Bloom filter for the leaf node\n        BloomFilter bloomFilter;\n        bool hasBloomFilter = false;\n    }\n</code></pre>"},{"location":"layout/#pageinternalnodes","title":"<code>Page::InternalNodes</code>","text":"<pre><code>/*\n *  4kb / 8kb chunk\n *  sorted by level\n */\nlevel#0 key-value pair 0 metadata (serialized by protobuf), jump_offset_L1_K0, jump_offset_L1_K1\nlevel#1 key-value pair 1 metadata (serialized by protobuf), jump_offset_L2_K0, jump_offset_L2_K1\nlevel#1 key-value pair 2 metadata (serialized by protobuf), jump_offset_L2_K1, jump_offset_L2_K2\n...\n// with padding\n</code></pre> <pre><code>struct InternalNodeData {\n        std::vector&lt;KeyValueWrapper&gt; keys;\n        std::vector&lt;uint64_t&gt; childOffsets; // Offsets to child pages, size = keys.size() + 1\n    }\n</code></pre>"},{"location":"layout/#pagebloomfilter","title":"<code>Page::BloomFilter</code>","text":"<p>TBD</p>"},{"location":"layout/#pageclusteredindex","title":"<code>Page::ClusteredIndex</code>","text":"<p>TBD</p>"}]}